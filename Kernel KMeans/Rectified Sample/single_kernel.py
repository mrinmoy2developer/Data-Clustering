# -*- coding: utf-8 -*-
"""single_kernel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C85khHsDoFUB0-V7oaDnRLXsqVX7EXIy
"""

import numpy as np
from sklearn.metrics import pairwise_distances
import random
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.metrics import adjusted_rand_score as ARI

def Kkmens(X, n_c, runs=10, max_iter=100, sigma=0.1, tol=1e-16):
    # Gaussian kernel
    K = np.exp(-(pairwise_distances(X, X, metric='sqeuclidean', n_jobs=-1)/2*sigma**2))
    K_diag = np.diag(K)
    prv_cost = +np.inf
    

    for q in range(runs):
        mem = np.random.randint(0,n_c, size=X.shape[0])
        #print(q)

        for n_iter in range(max_iter):
            #print(n_iter)
            prv_mem = np.zeros(mem.shape)
            dist = np.zeros((X.shape[0], n_c))
            cost = np.zeros(n_c)
            
            for j in range(n_c):
                dist[:,j] = K_diag
                dist[:,j] = (dist[:,j] + (-2*K[:,mem == j].sum(axis=1)/(mem == j).sum()) + (K[:, mem == j][mem == j, :].sum()/((mem == j).sum()**2)))
               
                #cost[j] = (K[:, mem == j][mem == j, :].sum())
                cost[j] = (dist.sum())
            #print(mem)
            #print(A)
            #print(cost)
            cost = np.sum(cost)
            #print(cost)
            #print(mem)
            prv_mem = mem
            mem = dist.argmin( axis = 1 )
            #print(mem)
            #print(prv_mem)
            if np.linalg.norm(prv_mem - mem) < 1e-6:
                print('converged')
                print(n_iter)
                break
        #print(cost.shape)
        #print(cost)
        if prv_cost > cost:
            prv_cost = cost
            #print(prv_cost)
            mem_f = mem
    return mem_f , prv_cost

def make_blobs(C=[[1,2],[5,6],[10,4]],S=[[[1,0],[0,2]],[[3,0],[0,4]],[[3,0],[0,1]]],N=[60,80,100]):
    X=np.empty([0,2])
    for i in range(len(N)):
        x=np.random.multivariate_normal(C[i],S[i],N[i])
        X=np.append(X,x,axis=0)
    return X
    
def make_rings(C=[[0]*2]*2,R=[10,20],N=[100,200],noise=2):
    X=np.empty([0,2])
    for i in range(len(N)):
        theta=np.linspace(0,2*np.pi,num=N[i])
        x=[C[i]]*N[i]+R[i]*np.stack((np.cos(theta),np.sin(theta)),axis=1)+np.random.multivariate_normal([0]*2,np.diag([noise]*2),N[i])
        X=np.append(X,x,axis=0)
    return X

def make_moons(C=[[0]*2,[20,0]],R=[20,20],N=[100,100],A=[[-0.1,np.pi*1.1],[np.pi*0.9,2.1*np.pi]],noise=2):
    X=np.empty([0,2])
    for i in range(len(N)):
        theta=np.linspace(A[i][0],A[i][1],num=N[i])
        x=[C[i]]*N[i]+R[i]*np.stack((np.cos(theta),np.sin(theta)),axis=1)+np.random.multivariate_normal([0]*2,np.diag([noise]*2),N[i])
        X=np.append(X,x,axis=0)
    return X


if __name__ == '__main__':

    '''
    from sklearn.datasets import load_iris
    X = load_iris().data
    
    y= load_iris().target
    k = len(np.unique(y))
    '''

    M = make_rings()
    X = M
    #X = x.astype(float)
    y= np.array([0]*100+[1]*200)
    #x = x[np.random.permutation(x.shape[0])[0:1000]]
    #plt.scatter(x[:,0], x[:,1])
    #print(x[1,:], x.shape, x.dtype, np.zeros((5)).dtype)
    k = len(np.unique(y))
    #k = 2
    
    mem, min_cost = Kkmens(X, k)
    print('Minimun cost =',min_cost)
   
    print('ARI =', ARI(y, mem))
    import matplotlib.pyplot as plt
    for iter1 in range(k):
        plt.scatter(X[mem == iter1, 0], X[mem == iter1, 1], marker='x')
    plt.show()




